<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>The Caramel Life</title>
<style>
  :root{
    --caramel:#C77C36;
    --caramel-deep:#9A5A24;
    --caramel-light:#F3B773;
    --cream:#FFECD1;
    --choc:#3D2A1B;
    --mint:#3ED1A6;
    --berry:#FF4D6D;
    --gold:#FFD166;
    --shadow:rgba(0,0,0,0.25);
    --bg:#0b0a0a;
  }
  html, body {
    margin:0;
    height:100%;
    background: radial-gradient(1200px 800px at 50% 0%, #1a1411 0%, #0b0a0a 60%);
    color:var(--cream);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    overflow:hidden;
  }
  #wrap { display:flex; flex-direction:column; height:100%; }
  header {
    padding:8px 12px;
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0));
    border-bottom:1px solid rgba(255,255,255,0.06);
  }
  .logo {
    display:flex; align-items:center; gap:10px; user-select:none;
    text-shadow:0 2px 8px var(--shadow);
  }
  .badge {
    width:36px; height:36px; border-radius:12px;
    background: conic-gradient(from 0deg, var(--caramel), var(--caramel-light), var(--caramel-deep), var(--caramel));
    box-shadow: 0 4px 16px rgba(199,124,54,0.5), inset 0 2px 6px rgba(255,255,255,0.25);
    position:relative;
  }
  .badge:after{
    content:""; position:absolute; inset:6px; border-radius:10px;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.6), rgba(255,255,255,0) 50%);
    filter: blur(1px);
  }
  .brand { font-weight:800; letter-spacing:0.5px;}
  .subtitle { opacity:0.8; font-size:12px; }
  .stats { display:flex; gap:16px; font-weight:600; }
  .pill { background:rgba(255,255,255,0.06); padding:6px 10px; border-radius:999px; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08); }
  #game { flex:1; display:flex; align-items:center; justify-content:center; }
  canvas { box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.06); border-radius:16px; background:#111; }
  footer { padding:8px 12px; opacity:0.8; display:flex; gap:10px; align-items:center; justify-content:space-between; font-size:12px; }
  /* Mobile Controls */
  #controls { position:fixed; bottom:14px; right:14px; width:min(44vw, 280px); aspect-ratio:1/1; opacity:0.9; touch-action:manipulation; }
  .btn { position:absolute; width:30%; height:30%; background:rgba(255,255,255,0.06); border-radius:14px; display:grid; place-items:center;
         box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 4px 12px rgba(0,0,0,0.35); user-select:none; }
  .btn:active { filter:brightness(1.2); }
  .up    { left:35%; top:0; }
  .down  { left:35%; bottom:0; }
  .left  { left:0; top:35%; }
  .right { right:0; top:35%; }
  .arrow { width:0; height:0; border-style:solid; }
  .up .arrow    { border-width:0 14px 20px 14px; border-color:transparent transparent var(--cream) transparent; }
  .down .arrow  { border-width:20px 14px 0 14px; border-color:var(--cream) transparent transparent transparent; }
  .left .arrow  { border-width:14px 20px 14px 0; border-color:transparent var(--cream) transparent transparent; }
  .right .arrow { border-width:14px 0 14px 20px; border-color:transparent transparent transparent var(--cream); }
  @media (min-width:900px) {
    #controls{ display:none; }
  }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="logo">
      <div class="badge" aria-hidden="true"></div>
      <div>
        <div class="brand">THE CARAMEL LIFE</div>
        <div class="subtitle">Auto-move • Particle juice • Mobile ready</div>
      </div>
    </div>
    <div class="stats">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Level: <span id="level">1</span></div>
      <div class="pill">Lives: <span id="lives">3</span></div>
    </div>
  </header>
  <div id="game"><canvas id="c" width="960" height="720"></canvas></div>
  <footer>
    <div>Tap or press arrows/WASD. Player auto-moves on load.</div>
    <div>Tip: Eat a Power Caramel to make enemies vulnerable.</div>
  </footer>
</div>

<!-- Mobile Controls -->
<div id="controls">
  <div class="btn up"    data-dir="up"><div class="arrow"></div></div>
  <div class="btn down"  data-dir="down"><div class="arrow"></div></div>
  <div class="btn left"  data-dir="left"><div class="arrow"></div></div>
  <div class="btn right" data-dir="right"><div class="arrow"></div></div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const tile = 24; // grid size
  const cols = Math.floor(W / tile);
  const rows = Math.floor(H / tile);

  // HUD
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const livesEl = document.getElementById('lives');

  // Colors
  const colors = {
    bg: '#0b0a0a',
    wall1:'#2a1f18',
    wall2:'#4b3426',
    caramel:'#C77C36',
    caramelLight:'#F3B773',
    caramelDeep:'#9A5A24',
    cream:'#FFECD1',
    choc:'#3D2A1B',
    mint:'#3ED1A6',
    berry:'#FF4D6D',
    gold:'#FFD166',
    enemy1:'#ff8fab', enemy2:'#bde0fe', enemy3:'#caffbf', enemy4:'#ffd6a5',
    vulnerable:'#4ecdc4',
  };

  // Maze generation (handcrafted pattern that looks like caramel swirl on an apple)
  // 0 empty, 1 wall, 2 treat, 3 power treat
  function makeMaze(level=1){
    const grid = Array.from({length:rows},()=>Array(cols).fill(0));
    // borders
    for(let y=0;y<rows;y++){ grid[y][0]=1; grid[y][cols-1]=1; }
    for(let x=0;x<cols;x++){ grid[0][x]=1; grid[rows-1][x]=1; }

    // caramel swirl paths
    const cx = Math.floor(cols/2), cy = Math.floor(rows/2);
    const rings = 5 + Math.min(6, level);
    for(let r=2;r<rings;r++){
      const steps = Math.floor(2*Math.PI*(r*2));
      for(let i=0;i<steps;i++){
        const a = i/steps * Math.PI*2 + (r%2?0:Math.PI/8);
        const x = Math.floor(cx + Math.cos(a)*r*2);
        const y = Math.floor(cy + Math.sin(a)*r*1.2);
        if(x>1 && y>1 && x<cols-2 && y<rows-2){
          grid[y][x]=1;
          // accent thickness
          if((i%5)===0 && Math.random()<0.6 && x+1<cols-1) grid[y][x+1]=1;
        }
      }
    }
    // carve some gates
    for(let y=2;y<rows-2;y+=6){
      for(let x=2;x<cols-2;x+=12){
        grid[y][x]=0;
      }
    }
    // place treats & power treats
    for(let y=1;y<rows-1;y++){
      for(let x=1;x<cols-1;x++){
        if(grid[y][x]===0){
          grid[y][x] = (Math.random()<0.05) ? 3 : 2;
        }
      }
    }
    return grid;
  }

  // Entities
  const player = {
    x: tile*2, y: tile*2, dir: {x:1,y:0}, speed: 2.6,
    radius: 9, lives:3, score:0, glowPulse:0
  };
  const enemies = [];
  const particles = [];
  let grid = makeMaze(1);
  let level = 1;
  let vulnerableTimer = 0;
  let gameOver = false;

  function resetPlayer(){
    // spawn in an empty spot
    for(let y=1;y<rows-1;y++){
      for(let x=1;x<cols-1;x++){
        if(grid[y][x]===0){ player.x = x*tile+tile/2; player.y = y*tile+tile/2; x=cols; y=rows; break; }
      }
    }
    player.dir = {x:1,y:0}; // auto move right on load / reset
  }

  function spawnEnemies(n=4){
    enemies.length = 0;
    const palette = [colors.enemy1, colors.enemy2, colors.enemy3, colors.enemy4];
    for(let i=0;i<n;i++){
      const e = {
        x: (cols-3-i)*tile, y: (rows-3)*tile,
        dir: {x: (i%2?1:-1), y:0}, speed: 2.2 + Math.random()*0.6,
        color: palette[i%palette.length], size: 10, blink:0
      };
      enemies.push(e);
    }
  }

  resetPlayer();
  spawnEnemies(4);

  // Helpers
  function tileAt(px, py){
    const x = Math.floor(px / tile);
    const y = Math.floor(py / tile);
    if(x<0||y<0||x>=cols||y>=rows) return 1;
    return grid[y][x];
  }
  function canMove(x, y, dir, radius=8){
    const nx = x + dir.x;
    const ny = y + dir.y;
    // check 4 corners
    const corners = [
      {x:nx-radius, y:ny-radius},
      {x:nx+radius, y:ny-radius},
      {x:nx-radius, y:ny+radius},
      {x:nx+radius, y:ny+radius},
    ];
    for(const c of corners){
      if(tileAt(c.x, c.y)===1) return false;
    }
    return true;
  }

  function addParticles(x,y, baseColor){
    for(let i=0;i<10;i++){
      particles.push({
        x, y,
        vx: (Math.random()*2-1)*2.2,
        vy: (Math.random()*2-1)*2.2,
        life: 26 + Math.random()*12,
        color: (i%2===0?colors.caramelLight:baseColor)
      });
    }
  }

  function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx; p.y += p.vy;
      p.vy *= 0.98; p.vx *= 0.98;
      p.life--;
      if(p.life<=0) particles.splice(i,1);
    }
  }

  // Input (auto move enabled; keys adjust direction on the fly)
  const keys = {};
  const dirs = {
    'ArrowUp': {x:0,y:-2.6}, 'KeyW':{x:0,y:-2.6},
    'ArrowDown': {x:0,y:2.6}, 'KeyS':{x:0,y:2.6},
    'ArrowLeft': {x:-2.6,y:0}, 'KeyA':{x:-2.6,y:0},
    'ArrowRight': {x:2.6,y:0}, 'KeyD':{x:2.6,y:0},
  };
  window.addEventListener('keydown', (e)=>{
    if(dirs[e.code]){
      const d = dirs[e.code];
      // attempt to turn if space is free in that axis
      if(canMove(player.x, player.y, d, player.radius)) player.dir = {x:Math.sign(d.x), y:Math.sign(d.y)};
    }
  });

  // Touch controls
  document.querySelectorAll('#controls .btn').forEach(btn=>{
    btn.addEventListener('touchstart', e=>{
      const dir = btn.dataset.dir;
      if(dir==='up') player.dir={x:0,y:-1};
      if(dir==='down') player.dir={x:0,y:1};
      if(dir==='left') player.dir={x:-1,y:0};
      if(dir==='right') player.dir={x:1,y:0};
    }, {passive:true});
  });

  // Enemy AI: simple chase/roam with random turns at intersections
  function enemyAI(e){
    const speed = e.speed * (vulnerableTimer>0 ? 0.8 : 1.0);
    const options = [
      {x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}
    ].filter(d=> canMove(e.x, e.y, {x:d.x*speed, y:d.y*speed}, e.size));

    // bias toward player
    options.sort((a,b)=>{
      const da = Math.hypot((e.x+a.x*tile)-player.x, (e.y+a.y*tile)-player.y);
      const db = Math.hypot((e.x+b.x*tile)-player.x, (e.y+b.y*tile)-player.y);
      return (vulnerableTimer>0 ? da - db : db - da);
    });

    if(options.length){
      const best = options[0];
      e.dir = best;
    }

    e.x += e.dir.x * speed;
    e.y += e.dir.y * speed;
    // keep inside
    e.x = Math.max(tile, Math.min(W-tile, e.x));
    e.y = Math.max(tile, Math.min(H-tile, e.y));
  }

  // Collisions
  function circleHit(ax,ay,ar, bx,by,br){
    return Math.hypot(ax-bx, ay-by) < (ar+br);
  }

  // Game Loop
  let then = 0;
  function loop(now){
    requestAnimationFrame(loop);
    const dt = (now-then)/16.67; // 60fps normalized
    then = now;

    // Update logic
    const pSpeed = player.speed * (keys['ShiftLeft']?1.2:1);
    const moveVec = {x: player.dir.x*pSpeed, y: player.dir.y*pSpeed};
    if(canMove(player.x, player.y, moveVec, player.radius)){
      player.x += moveVec.x;
      player.y += moveVec.y;
    } else {
      // gentle slide along walls to avoid "dead stops"
      if(player.dir.x!==0){
        const tryY1 = {x:0,y:1}, tryY2 = {x:0,y:-1};
        if(canMove(player.x, player.y, tryY1, player.radius)) player.y += 1;
        else if(canMove(player.x, player.y, tryY2, player.radius)) player.y -= 1;
      } else if(player.dir.y!==0){
        const tryX1 = {x:1,y:0}, tryX2 = {x:-1,y:0};
        if(canMove(player.x, player.y, tryX1, player.radius)) player.x += 1;
        else if(canMove(player.x, player.y, tryX2, player.radius)) player.x -= 1;
      }
    }

    // Treat collection
    const tx = Math.floor(player.x/tile), ty = Math.floor(player.y/tile);
    if(grid[ty] && (grid[ty][tx]===2 || grid[ty][tx]===3)){
      const kind = grid[ty][tx];
      grid[ty][tx] = 0;
      const gain = (kind===3)? 50 : 10;
      player.score += gain;
      scoreEl.textContent = player.score;
      addParticles(tx*tile+tile/2, ty*tile+tile/2, colors.caramel);
      if(kind===3){
        vulnerableTimer = 600; // ~10 seconds at 60fps
        enemies.forEach(e=> e.blink = 1);
      }
      // level complete?
      let remaining=0;
      for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(grid[y][x]===2||grid[y][x]===3) remaining++;
      if(remaining===0){
        level++;
        levelEl.textContent = level;
        grid = makeMaze(level);
        resetPlayer();
        spawnEnemies(4+Math.min(2, Math.floor(level/2)));
      }
    }

    // Enemies
    enemies.forEach(e=>{
      enemyAI(e);
      // collide with player
      if(circleHit(player.x,player.y,player.radius+2, e.x,e.y,e.size)){
        if(vulnerableTimer>0){
          // eat enemy
          player.score += 100;
          scoreEl.textContent = player.score;
          addParticles(e.x, e.y, colors.mint);
          // respawn enemy
          e.x = (cols-3)*tile; e.y = (rows-3)*tile;
          e.dir = {x:-1,y:0};
        }else{
          // lose life
          player.lives--;
          livesEl.textContent = player.lives;
          addParticles(player.x, player.y, colors.berry);
          resetPlayer();
          if(player.lives<=0){
            gameOver = true;
          }
        }
      }
    });
    if(vulnerableTimer>0) vulnerableTimer--;
    updateParticles();

    // Render
    ctx.clearRect(0,0,W,H);
    // background caramel apple gradient
    const g = ctx.createRadialGradient(W*0.5, H*0.4, 40, W*0.5, H*0.45, Math.max(W,H)*0.7);
    g.addColorStop(0, colors.caramelLight);
    g.addColorStop(0.4, colors.caramel);
    g.addColorStop(1, colors.choc);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // walls with glossy highlight
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        if(grid[y][x]===1){
          const px = x*tile, py = y*tile;
          const grad = ctx.createLinearGradient(px,py,px,py+tile);
          grad.addColorStop(0, colors.wall2);
          grad.addColorStop(1, colors.wall1);
          ctx.fillStyle = grad;
          ctx.shadowColor = 'rgba(0,0,0,0.5)';
          ctx.shadowBlur = 6;
          ctx.fillRect(px,py,tile,tile);
          // highlight
          ctx.shadowBlur = 0;
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
          ctx.fillRect(px,py, tile, 3);
        } else if(grid[y][x]===2 || grid[y][x]===3){
          // treats
          const px = x*tile+tile/2, py = y*tile+tile/2;
          ctx.beginPath();
          if(grid[y][x]===3){
            // power caramel: bigger and glowing
            ctx.fillStyle = colors.gold;
            ctx.shadowColor = colors.gold;
            ctx.shadowBlur = 18;
            ctx.arc(px, py, 6, 0, Math.PI*2);
          }else{
            ctx.fillStyle = colors.cream;
            ctx.shadowColor = colors.cream;
            ctx.shadowBlur = 8;
            ctx.arc(px, py, 3, 0, Math.PI*2);
          }
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    }

    // particles
    particles.forEach(p=>{
      ctx.globalAlpha = Math.max(0, p.life/30);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, 3, 3);
      ctx.globalAlpha = 1;
    });

    // enemies
    enemies.forEach(e=>{
      ctx.save();
      const flashing = (vulnerableTimer>0);
      if(flashing){
        // flash cyan/white
        const t = Math.floor(now/120)%2;
        ctx.fillStyle = t ? colors.vulnerable : '#e8ffff';
      }else{
        ctx.fillStyle = e.color;
      }
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 12;
      // rounded caramel drop shape
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.size, Math.PI*0.1, Math.PI*1.9);
      ctx.quadraticCurveTo(e.x, e.y+e.size*1.6, e.x+e.size*0.2, e.y);
      ctx.closePath();
      ctx.fill();
      // eyes
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(e.x-4, e.y-2, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(e.x+4, e.y-2, 2, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    });

    // player (subtle glow)
    ctx.save();
    player.glowPulse += 0.08;
    ctx.shadowBlur = 20 + Math.sin(player.glowPulse)*10;
    ctx.shadowColor = 'rgba(255, 236, 209, 0.9)';
    const gradP = ctx.createRadialGradient(player.x-4, player.y-6, 2, player.x, player.y, 16);
    gradP.addColorStop(0, colors.caramelLight);
    gradP.addColorStop(1, colors.caramelDeep);
    ctx.fillStyle = gradP;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Game over
    if(gameOver){
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle=colors.cream; ctx.textAlign='center';
      ctx.font='700 52px system-ui, sans-serif';
      ctx.fillText('Game Over', W/2, H/2-10);
      ctx.font='400 20px system-ui, sans-serif';
      ctx.fillText('Press R to restart', W/2, H/2+26);
      return; // freeze frame
    }
  }
  requestAnimationFrame(loop);

  // Restart
  window.addEventListener('keydown', (e)=>{
    if(e.code==='KeyR' && gameOver){
      level = 1; player.lives=3; player.score=0; livesEl.textContent=3; scoreEl.textContent=0; levelEl.textContent=1;
      grid = makeMaze(level); resetPlayer(); spawnEnemies(4); gameOver=false;
    }
  });

  // Resize canvas to fit while preserving aspect
  function fit(){
    const rect = document.getElementById('game').getBoundingClientRect();
    const scale = Math.min(rect.width / W, rect.height / H);
    canvas.style.transformOrigin = 'top left';
    canvas.style.transform = `scale(${scale})`;
  }
  window.addEventListener('resize', fit);
  fit();
})();</script>
</body>
</html>
